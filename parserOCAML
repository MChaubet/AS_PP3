%{
	#include <stdbool.h>
	#include "ast.h"
	#include "main.h"

	int yylex(void);
	void yyerror(char *);
%}

%output "parser.tab.c"

%union{
	int value;
	char * name;
	struct ast * ast;
	struct attributes * attributes;
}


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** * GESTION DES TOKENS ** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* Retourner par le scan.l */
%token < name >  TAG		// Nom de balise
%token < name >  INST		// Mot clé  OCaml
%token < name >  NAME		// Variable OCaml
%token < name >  MOT		// Mot d'un texte
%token < value > INTEGER	// Un nombre


%token < name >  ARROW	"=>"	// Fleche (fonction)

/* Token de comparaison */
%token < name >  OU		"||"	// OU logique
%token < name >  ET		"&&"	// ET logique
%token < name >  INF	"<"		// Inférieur relationnel
%token < name >  SUP	">"		// Supérieur relationnel
%token < name >  INF_EQ	"<="	// Inférieur ou égale relationnel
%token < name >  SUP_EQ	">="	// Supérieur ou égale relationnel
%token < name >  EQ		"=="	// Égale relationnel
%token < name >  NOT_EQ	"!="	// Non égale relationnel


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ** GESTION DES TYPES ** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
%type < ast > file

/* Déclarations */
%type < ast > declarations_globales
%type < ast > declaration_locale
%type < ast > declaration
%type < ast > functions
%type < ast > names

/* Expressions */
%type < ast > expr
%type < ast > conditional_expr
%type < ast > logical_expr
%type < ast > relational_expr
%type < ast > additive_expr
%type < ast > multiplicative_expr
%type < ast > factor_expr

/* Code XML HTML */
%type < ast > body
%type < ast > tree
%type < attributes > attributs
%type < ast > contenus
%type < ast > contenu
%type < ast > text
%type < ast > word_t
%type < ast > action


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** *** DEBUT GRAMMAIRE *** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
%start file
%%

file
		: declarations_globales body					{ $$ = mk_forest(false, $1, $2); }
		| body											{ $$ = $1; emit($$, "sortie.html");}
		;

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** *** GESTION DES DECLARATIONS DE TOUS TYPES **** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
declarations_globales
		: declaration ';' declarations_globales			{ $$ = ; mk_forest(false, $1, $3);}
		| declaration ';'								{ $$ = $1; }
		;

declaration
		: LET names '=' functions 						{ $$ = mk_fun($2, $4); }
		| LET REC names '=' functions 					{ $$ = mk_declrec($3, $5); }
		;

names
		: NAME names									{ $$ = mk_fun($1, $2); }
		| NAME											{ $$ = mk_fun($1, NULL); }
		;

functions
		: FUN names ARROW functions						{ ajouter_body($2->node->fun->body, $4); $$ = $2; }
		| expr											{ $$ = $1; }
		;
		
declaration_locale	/* Evaluation pour les IN et WHERE*/
		: LET NAME '=' expr IN expr						{ $$ = mk_app(mk_fun($2, $6), $4); }
		| LET REC NAME '=' expr IN expr					{ $$ = mk_app(mk_fun($3, $7), mk_declrec($3, $5)); }
		| expr WHERE name '=' expr						{ $$ = mk_app(mk_fun($3, $1), $5); }
		| expr WHERE REC name '=' expr					{ $$ = mk_app(mk_fun($3, $1), mk_declrec($4, $6)); }
		;

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** **** GESTION DES EXPRESSIONS DE TOUS TYPES **** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
expr
		: logical_expr									{ $$ = $1; }
		| relational_expr								{ $$ = $1; }
		;

conditional_expr
		: INST logical_expr INST expr INST expr			{ if(!strcmp($1, "if") && !strcmp($3, "then") && !strcmp($5, "else")) $$ = mk_cond($2, $4, $6); }
		| logical_expr									{ $$ = $1; }
		;

logical_expr
		: logical_expr OU relational_expr				{ $$ = mk_app(mk_app(mk_binop(OR), $1), $3); }
		| logical_expr ET relational_expr				{ $$ = mk_app(mk_app(mk_binop(AND), $1), $3); }
		| relational_expr								{ $$ = $1; }
		;
		
relational_expr 
		: relational_expr INF		additive_expr		{ $$ = mk_app(mk_app(mk_binop(LE), $1), $3); }
		| relational_expr SUP		additive_expr		{ $$ = mk_app(mk_app(mk_binop(LEQ), $1), $3); }
		| relational_expr SUP_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(GE), $1), $3); }
		| relational_expr INF_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(GEQ), $1), $3); }
		| relational_expr EQ		additive_expr		{ $$ = mk_app(mk_app(mk_binop(EQ), $1), $3); }
		| relational_expr NOT_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(NEQ), $1), $3); }
		| additive_expr									{ $$ = $1; }
		;

additive_expr
		: additive_expr '+' multiplicative_expr			{ $$ = mk_app(mk_app(mk_binop(PLUS), $1), $3); }
		| additive_expr '-' multiplicative_expr			{ $$ = mk_app(mk_app(mk_binop(MINUS), $1), $3); }
		| multiplicative_expr							{ $$ = $1; }
		;

multiplicative_expr
		: multiplicative_expr '*'  factor_expr			{ $$ = mk_app(mk_app(mk_binop(MULT), $1), $3); }
		| multiplicative_expr '\/' factor_expr			{ $$ = mk_app(mk_app(mk_binop(DIV), $1), $3); }
		| factor_expr									{ $$ = $1; }
		;

factor_expr
		: '(' expr ')'									{ $$ = $2; }
		| '!' expr										{ $$ = mk_app(mk_unaryop(NOT), $2); }
		| '"' text '"'									{ $$ = $2; }
		| tree											{ $$ = $1; }
		| INTEGER										{ $$ = mk_integer($1); }
		;


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** *****  GESTION CODE XML/HTML  ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
body
		: tree body										{ $$ = mk_forest(false, $1, $2); }
		| action body									{ $$ = mk_forest(false, $1, $2); }
		| tree											{ $$ = $1; }
		| action										{ $$ = $1; }
		;


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** **** GESTION HTML ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
tree
		: TAG '[' attributs ']' '{' contenus '}'		{ $$ = mk_tree($1, true, false, false, $3, $6); }
		| TAG '[' attributs ']' '/'						{ $$ = mk_tree($1, true, true, false, $3, NULL); }
		| TAG '{' contenus '}'							{ $$ = mk_tree($1, true, false, false, NULL, $3); }
		| TAG '/'										{ $$ = mk_tree($1, true, true, false, NULL, NULL); }
		| '{' contenus '}'								{ $$ = $2; }
		;

attributs
		: TAG '=' '"' text '"' attributs				{ $$ = mk_attributes(mk_var($1), $4, $6); }
		| TAG '=' '"' text '"'							{ $$ = mk_attributes(mk_var($1), $4, NULL);}
		;

contenus
		: contenu contenus								{ $$ = mk_forest(false, $1, $2); }
		| contenu										{ $$ = $1; }
		| action										{ /*TODO*/; }
		;

contenu
		: tree											{ $$ = $1; }
		| '"' text '"'									{ $$ = $2; }
		| action ','									{ /*TODO*/; }
		;

text
		: word_t text									{ $$ = mk_forest(false, $1, $2); }
		| word_t										{ $$ = $1; }
		;

word_t
		: MOT ' ' 										{ $$ = mk_tree("text", false, false, true, NULL, mk_word($1)); }
		| MOT	 										{ $$ = mk_tree("text", false, false, false, NULL, mk_word($1)); }
		;


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** **** GESTION CAML ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
action 
		: declaration_locale							{ ; }
		| OPERATION										{ ; }
		| NAME											{ /*Vérifier qu'il existe puis afficher*/; }
		| MATCH											{ /*TODO Lacoste*/; }
		| INST expr INST action INST action				{ /*TODO if .. then .. else VOIR DANS EXPRESSIONS */; }
		| INST '"' MOT '"' tree							{ /*emit "fichier.txt" tree*/; }
		| expr											{ /*TODO Pas sur*/; }
		;

%%
