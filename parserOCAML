%{
	#include <stdbool.h>
	#include "ast.h"
	#include "main.h"

	int yylex(void);
	void yyerror(char *);
%}

%output "parser.tab.c"

%union{
	int value;
	char * name;
	struct ast * ast;
	struct attributes * attributes;
}

%token < name > TAG		// Nom de balise
%token < name > INST	// Mot clé  OCaml
%token < name > NAME	// Variable OCaml
%token < name > MOT		// Mot d'un texte

%token ARROW "=>"


%type < ast > file
%type < ast > declarations_globales
%type < ast > declaration_locale
%type < ast > declaration
%type < ast > functions
%type < ast > expr
%type < ast > names
%type < ast > body
%type < ast > tree
%type < ast > contenus
%type < ast > contenu
%type < ast > action
%type < ast > text
%type < ast > word_t

%type < attributes > attributs

%start file

%%


file
		: declarations_globales body					{ $$ = mk_forest(false, $1, $2); }
		| body											{ $$ = $1; emit($$, "sortie.html");}
		;

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** *** GESTION DES DECLARATIONS DE TOUS TYPES **** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
declarations_globales
		: declaration ';' declarations_globales			{ ; }
		| declaration ';'								{ ; }
		| declaration ';' NAME ';' declarations_globales{ ; }
		| declaration ';' NAME ';'						{ ; }
		;
		
declaration_locale
		: declaration INST tree							{ /*Creer un lien entre la variable et le body*/; }
		| tree declaration								{ /*Creer un lien entre la variable et le body*/; }
		;

declaration
		: INST names '=' expr							{ /*Déclaration d'une variable ou d'une fonction*/ /*TODO DISTINCTION FOREST/VAR LET/WHERE*/; }
		| INST INST names '=' expr						{ /*Déclaration d'une fonction récurcive*/; }
		| INST names '=' functions expr					{ /*Déclaration d'une fonction, sous fonction*/; }
		| INST INST names '=' functions expr			{ /*Déclaration d'une fonction récurcive, sous fonction*/; }
		;

functions
		: INST names ARROW functions					{ /*Faire une foret de fonction*/; }
		| INST names ARROW								{ /*Faire une fonction*/; }
		;

names
		: NAME names									{ $$ = mk_forest(false, mk_var($1), $2); }
		| NAME											{ $$ = mk_var($1); }
		;


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** **** GESTION DES EXPRESSIONS DE TOUS TYPES **** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
expr
		: logical_expr									{ $$ = $1; }
		| relational_expr								{ $$ = $1; }
		;

logical_expr
		: logical_expr OU relational_expr				{ $$ = mk_app(mk_app(mk_binop(OR), $1), $3); }
		| logical_expr ET relational_expr				{ $$ = mk_app(mk_app(mk_binop(AND), $1), $3); }
		| relational_expr								{ $$ = $1; }
		;
		
relational_expr 
		: relational_expr INF		additive_expr		{ $$ = mk_app(mk_app(mk_binop(LE), $1), $3); }
		| relational_expr SUP		additive_expr		{ $$ = mk_app(mk_app(mk_binop(LEQ), $1), $3); }
		| relational_expr SUP_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(GE), $1), $3); }
		| relational_expr INF_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(GEQ), $1), $3); }
		| relational_expr EQ		additive_expr		{ $$ = mk_app(mk_app(mk_binop(EQ), $1), $3); }
		| relational_expr NOT_EQ	additive_expr		{ $$ = mk_app(mk_app(mk_binop(NEQ), $1), $3); }
		| additive_expr									{ $$ = $1; }
		;

additive_expr
		: additive_expr '+' multiplicative_expr			{ $$ = mk_app(mk_app(mk_binop(PLUS), $1), $3); }
		| additive_expr '-' multiplicative_expr			{ $$ = mk_app(mk_app(mk_binop(MINUS), $1), $3); }
		| multiplicative_expr							{ $$ = $1; }
		;

multiplicative_expr
		: multiplicative_expr '*'  cast_expr			{ $$ = mk_app(mk_app(mk_binop(MULT), $1), $3); }
		| multiplicative_expr '\/' cast_expr			{ $$ = mk_app(mk_app(mk_binop(DIV), $1), $3); }
		| cast_expr										{ $$ = $1; }
		;

cast_expr
		: '(' expr ')'									{ $$ = $2; }
		| '"' text '"'									{ $$ = $2; }
		| tree											{ $$ = $2; }
		;


/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** *****  GESTION CODE XML/HTML  ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
body
		: tree body										{ $$ = mk_forest(false, $1, $2); }
		| action body									{ $$ = mk_forest(false, $1, $2); }
		| tree											{ $$ = $1; }
		| action										{ $$ = $1; }
		;

tree
		: TAG '[' attributs ']' '{' contenus '}'		{ $$ = mk_tree($1, true, false, false, $3, $6); }
		| TAG '[' attributs ']' '/'						{ $$ = mk_tree($1, true, true, false, $3, NULL); }
		| TAG '{' contenus '}'							{ $$ = mk_tree($1, true, false, false, NULL, $3); }
		| TAG '/'										{ $$ = mk_tree($1, true, true, false, NULL, NULL); }
		| '{' contenus '}'								{ $$ = $2; }
		;

attributs
		: TAG '=' '"' text '"' attributs				{ $$ = mk_attributes(mk_var($1), $4, $6); }
		| TAG '=' '"' text '"'							{ $$ = mk_attributes(mk_var($1), $4, NULL);}
		;

contenus
		: contenu contenus								{ $$ = mk_forest(false, $1, $2); }
		| contenu										{ $$ = $1; }
		| action										{ ; }
		;

contenu
		: tree											{ $$ = $1; }
		| '"' text '"'									{ $$ = $2; }
		| action ','									{ ; }
		;

text
		: word_t text									{ $$ = mk_forest(false, $1, $2); }
		| word_t										{ $$ = $1; }
		;

word_t
		: MOT ' ' 										{ $$ = mk_tree("text", false, false, true, NULL, mk_word($1)); }
		| MOT	 										{ $$ = mk_tree("text", false, false, false, NULL, mk_word($1)); }
		;

/*TODO Faire une enumération de tous les cas possibles*/
action 
		: declaration_locale							{ ; }
		| OPERATION
		| NAME											{ /*Vérifier qu'il existe puis afficher*/; }
		| MATCH											{ /*TODO Lacoste*/; }
		| INST expr INST action INST action				{ /*if .. then .. else*/; }
		| INST '"' MOT '"' tree							{ /*emit "fichier.txt" tree*/; }
		| expr											{ /*TODO Pas sur*/; }
		;

%%
